// Ceres Solver - A fast non-linear least squares minimizer
// Copyright 2015 Google Inc. All rights reserved.
// http://ceres-solver.org/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice,
//   this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.
// * Neither the name of Google Inc. nor the names of its contributors may be
//   used to endorse or promote products derived from this software without
//   specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
// Author: sameeragarwal@google.com (Sameer Agarwal)

#include "ceres/ceres.h"
#include "glog/logging.h"

using ceres::AutoDiffCostFunction;
using ceres::CostFunction;
using ceres::Problem;
using ceres::Solve;
using ceres::Solver;

#ifndef M_PI
#define M_PI 3.14159265358979
#endif

#define deg_to_rad(deg) (((deg)/360)*2*M_PI)
#define rad_to_deg(rad) (((rad)/2/M_PI)*360)

// Data generated using the following octave code.
//   randn('seed', 23497);
//   m = 0.3;
//   c = 0.1;
//   x=[0:0.075:5];
//   y = exp(m * x + c);
//   noise = randn(size(x)) * 0.2;
//   y_observed = y + noise;
//   data = [x', y_observed'];

const int kNumObservations = 100;
// clang-format off
const double data[] = {

  0.0,0.0,3.1364671578153582,
0.0,0.08726646259971647,3.337962453852935,
0.0,0.17453292519943295,3.5314167995011863,
0.0,0.2617993877991494,3.715357890378802,
0.0,0.3490658503988659,3.8883858237175346,
0.0,0.4363323129985824,4.049183752467555,
0.0,0.5235987755982988,4.1965279072986315,
0.0,0.6108652381980153,4.329296910223666,
0.0,0.6981317007977318,4.446480308962283,
0.0,0.7853981633974483,4.547186267092811,
0.08726646259971647,0.0,3.721231357313092,
0.08726646259971647,0.08726646259971647,3.914685702961343,
0.08726646259971647,0.17453292519943295,4.0986267938389584,
0.08726646259971647,0.2617993877991494,4.271654727177691,
0.08726646259971647,0.3490658503988659,4.432452655927712,
0.08726646259971647,0.4363323129985824,4.579796810758788,
0.08726646259971647,0.5235987755982988,4.712565813683822,
0.08726646259971647,0.6108652381980153,4.82974921242244,
0.08726646259971647,0.6981317007977318,4.930455170552968,
0.08726646259971647,0.7853981633974483,5.013917254926114,
0.17453292519943295,0.0,4.289090644965509,
0.17453292519943295,0.08726646259971647,4.473031735843124,
0.17453292519943295,0.17453292519943295,4.646059669181858,
0.17453292519943295,0.2617993877991494,4.806857597931878,
0.17453292519943295,0.3490658503988659,4.9542017527629545,
0.17453292519943295,0.4363323129985824,5.086970755687989,
0.17453292519943295,0.5235987755982988,5.204154154426606,
0.17453292519943295,0.6108652381980153,5.304860112557134,
0.17453292519943295,0.6981317007977318,5.388322196930281,
0.17453292519943295,0.7853981633974483,5.4539052106881805,
0.2617993877991494,0.0,4.835723268710763,
0.2617993877991494,0.08726646259971647,5.0087512020494955,
0.2617993877991494,0.17453292519943295,5.169549130799516,
0.2617993877991494,0.2617993877991494,5.316893285630592,
0.2617993877991494,0.3490658503988659,5.4496622885556265,
0.2617993877991494,0.4363323129985824,5.566845687294244,
0.2617993877991494,0.5235987755982988,5.667551645424772,
0.2617993877991494,0.6108652381980153,5.7510137297979185,
0.2617993877991494,0.6981317007977318,5.816596743555818,
0.2617993877991494,0.7853981633974483,5.863801560363667,
0.3490658503988659,0.0,5.3569690242163475,
0.3490658503988659,0.08726646259971647,5.517766952966368,
0.3490658503988659,0.17453292519943295,5.665111107797444,
0.3490658503988659,0.2617993877991494,5.797880110722479,
0.3490658503988659,0.3490658503988659,5.9150635094610955,
0.3490658503988659,0.4363323129985824,6.015769467591625,
0.3490658503988659,0.5235987755982988,6.09923155196477,
0.3490658503988659,0.6108652381980153,6.16481456572267,
0.3490658503988659,0.6981317007977318,6.212019382530519,
0.3490658503988659,0.7853981633974483,6.240486745229363,
0.4363323129985824,0.0,5.848860916546076,
0.4363323129985824,0.08726646259971647,5.996205071377152,
0.4363323129985824,0.17453292519943295,6.128974074302187,
0.4363323129985824,0.2617993877991494,6.246157473040803,
0.4363323129985824,0.3490658503988659,6.346863431171332,
0.4363323129985824,0.4363323129985824,6.430325515544478,
0.4363323129985824,0.5235987755982988,6.495908529302378,
0.4363323129985824,0.6108652381980153,6.543113346110227,
0.4363323129985824,0.6981317007977318,6.571580708809071,
0.4363323129985824,0.7853981633974483,6.581093963579708,
0.5235987755982988,0.0,6.307655351386872,
0.5235987755982988,0.08726646259971647,6.440424354311906,
0.5235987755982988,0.17453292519943295,6.557607753050523,
0.5235987755982988,0.2617993877991494,6.6583137111810515,
0.5235987755982988,0.3490658503988659,6.741775795554197,
0.5235987755982988,0.4363323129985824,6.807358809312097,
0.5235987755982988,0.5235987755982988,6.854563626119947,
0.5235987755982988,0.6108652381980153,6.88303098881879,
0.5235987755982988,0.6981317007977318,6.892544243589427,
0.5235987755982988,0.7853981633974483,6.88303098881879,
0.6108652381980153,0.0,6.729860626061943,
0.6108652381980153,0.08726646259971647,6.84704402480056,
0.6108652381980153,0.17453292519943295,6.9477499829310885,
0.6108652381980153,0.2617993877991494,7.031212067304235,
0.6108652381980153,0.3490658503988659,7.096795081062135,
0.6108652381980153,0.4363323129985824,7.143999897869984,
0.6108652381980153,0.5235987755982988,7.172467260568828,
0.6108652381980153,0.6108652381980153,7.181980515339464,
0.6108652381980153,0.6981317007977318,7.172467260568828,
0.6108652381980153,0.7853981633974483,7.143999897869984,
0.6981317007977318,0.0,7.112263503496497,
0.6981317007977318,0.08726646259971647,7.212969461627026,
0.6981317007977318,0.17453292519943295,7.296431546000171,
0.6981317007977318,0.2617993877991494,7.362014559758071,
0.6981317007977318,0.3490658503988659,7.409219376565921,
0.6981317007977318,0.4363323129985824,7.437686739264764,
0.6981317007977318,0.5235987755982988,7.447199994035401,
0.6981317007977318,0.6108652381980153,7.437686739264764,
0.6981317007977318,0.6981317007977318,7.409219376565921,
0.6981317007977318,0.7853981633974483,7.362014559758071,
0.7853981633974483,0.0,7.451953666892088,
0.7853981633974483,0.08726646259971647,7.5354157512652336,
0.7853981633974483,0.17453292519943295,7.600998765023133,
0.7853981633974483,0.2617993877991494,7.648203581830983,
0.7853981633974483,0.3490658503988659,7.6766709445298265,
0.7853981633974483,0.4363323129985824,7.686184199300463,
0.7853981633974483,0.5235987755982988,7.6766709445298265,
0.7853981633974483,0.6108652381980153,7.648203581830983,
0.7853981633974483,0.6981317007977318,7.600998765023133,
0.7853981633974483,0.7853981633974483,7.535415751265234,

};
// clang-format on

struct ExponentialResidual {
  ExponentialResidual(double q1, double q2, double y) : q1_(q1), q2_(q2), y_(y) {}

  template <typename T>
  bool operator()(const T* const x1, const T* const x2, const T* const x3, const T* const x4, const T* const x5, T* residual) const {
    residual[0] = y_ - (x3[0] * ceres::sin(q1_ + x1[0]) + x4[0] * ceres::sin(q1_ + x1[0] + q2_ + x2[0]) + x5[0]);
//    std::cout << "debug:" << residual[0] << std::endl;
    return true;
  }

 private:
  const double q1_, q2_;
  const double y_;
};

int main(int argc, char** argv) {
  google::InitGoogleLogging(argv[0]);

  double x1 = deg_to_rad(0.0); // 10
  double x2 = deg_to_rad(0.0); // 10
  double x3 = 4; // 4.5
  double x4 = 2; // 2.5
  double x5 = 1; // 1.5

  double q1 = data[0];
  double q2 = data[1];
  double y = x3 * std::sin(q1 + x1) + x4 * std::sin(q1 + x1 + q2 + x2) + x5;

  std::cout << "data[0][0]:" << data[0] << std::endl;
  std::cout << "data[0][1]:" << data[1] << std::endl;
  std::cout << "data[0][2]:" << data[2] << std::endl;

  std::cout << "y:" << y << std::endl;

  Problem problem;
  for (int i = 0; i < kNumObservations; ++i) {
    problem.AddResidualBlock(
        new AutoDiffCostFunction<ExponentialResidual, 1, 1, 1, 1, 1, 1>(
            new ExponentialResidual(data[3 * i], data[3 * i + 1], data[3 * i + 2])),
        nullptr,
        &x1,
        &x2,
        &x3,
        &x4,
        &x5);
  }

  Solver::Options options;
  options.max_num_iterations = 250;
  options.linear_solver_type = ceres::DENSE_QR;
  options.minimizer_progress_to_stdout = true;

  Solver::Summary summary;
  Solve(options, &problem, &summary);
  std::cout << summary.BriefReport() << "\n";
  std::cout << "Initial x1: " << 0.0 << " x2: " << 0.0 << "\n";
  std::cout << "Final   x1: " << x1 << " x2: " << x2 << " x3: " << x3 <<" x4: " << x4 <<" x5: " << x5 <<"\n";
  return 0;
}
